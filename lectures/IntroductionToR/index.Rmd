---
title       : Introduction to R
subtitle    : 
author      : Daniel Fischer 
job         : Natural Resources Institute Finland, Green Technology
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      # 
widgets     : [mathjax, bootstrap, quiz]            # {mathjax, quiz, bootstrap}
mode        : selfcontained # {standalone, draft}
license     : by-nc-sa
github      :
  user      : fischuu
  repo      : fischuu.github.io/lectures/IntroductionToR
             
--- .segue .dark

## Introduction

```{r, echo=FALSE}
setwd("/home/fischuu/git/fischuu.github.io/lectures/IntroductionToR")
rm(list=ls())
```

---

## Overview

1. Introduction
2. Import Data to R
3. Data Structures
4. R as Pocket Calculator and basics
5. Packages ("Add-Ons")
6. Plots
7. Statistical Models and Tests
8. Export Data and Figures

---

## History of R

* R was started by Ross Ihaka and Robert Gentleman (the ”R & R’s” of the University of Auckland) in 1992.

* R is an environment and language for data manipulation, calculation, graphical display and statistical analysis.

* R is published under GNU licence. This means it is an open source program and is distributed for free.

* R can be seen as an implementation or dialect of the S language. S was developed by Becker and Chambers 1984.

* The origin of the name is not known anymore (although there are obvious possibilities...).

---

## Why to use R?

* It is _easy_. Compared to real programming languages, R has a simplified syntax that can be used without big learning efforts.

* It is _open source_. This means you can alter or check every piece of code (or hope at least that someone else does it...).

* It is _friendly_. Usually the mailing lists (”Rhelp”) or online discussion forums (e.g. 'StackOverflow') are fast, friendly and helpful.

* It is an _universal tool_. Usually there is a function in R for everything, or if there isn’t, soon there will be.

* Good environment for sharing your analysis tools.

---

## Why not to use R?

* It is _difficult_. Compared to graphical-interface based tools like Excel a console might be shocking and repellent.

* It is _open source_. This means, you have to trust the functions are correct - but noone gives you a warranty for this. Use it on own risk!

* It is _hostile_. Mailing lists (”Rhelp”) or online discussion forums (e.g. 'StackOverflow') don’t like reocurring questions or questions showing no own efforts to solve a problem.

* It is _static_. These days the figures are too static compared to other, competing languages like Matlab. You hardly can interact with created figures.

* It is _slow_. Compared to real programming languages, R is slow (the price for being easy...), but C,C++ and other languages can be included into R programs to boost the speed.

---

## Where to get R?

* R is pre-compiled available for every common operating system, like Windows, Linux and Mac , and also for 32 and 64bit.

* It can be downloaded from the CRAN (”Comprehensive R Archive Network”) webpage: [http://cran.r-project.org] (http://cran.r-project.org).

* Usually there are 2-3 major updates per year.

* Linux user that use the apt package system, can include the CRAN server into it and receive those updates then automatically.

* On CRAN are also thousands of additional extensions (”packages”) available.

* The [Bioconductor] (https://www.bioconductor.org/) projects offers on top of that also hundreds of packages specialized for genomic data analysis.

* It should be possible for everyone (Windows users) in Luke to download R and RStudio from [Application Catalog]
(http://vancmss1/CMApplicationCatalog/#/SoftwareLibrary/AppListPageView.xaml) which is also found under the star
in the upper right corner of IE window


---

## How does R look like?

![](assets/img/RStudio.png)

---

## How to use a console?

* The symbol that 'waits' for the input is usually the > sign.

* One usually types the command there and sends it to the interpreter by pressing the Return key.

* If a command line starts with + instead of > the interpreter expects further input.

* Common reason for this are still open parantheses or quotations.

* A history of the last commands is accesible using the arrow keys ↑↓.

* The console is case-sensitive.

---

## How to start?

![](assets/img/RStudio-highlighted.png)

---

## How to start?

![](assets/img/RStudio2.png)

---

## The script window

* Using the console is alright for simple commands, but as soon as you apply a sequence of commands it gets messy

* For larger projects (e.g. analysing datasets) it is much more convenient to write and run a _script_.

* This has the advantage that the commands can easily be stored, changed and distributed.

* It is much easier to keep the overview over the project.

* It is easier to prepare the script and run it then as whole.

* Copy+Paste for similar tasks

---

## Demonstration of a typical R-Session

* Lets have a look on how a R session typically goes.

* The example situation is that we received from a colleague an R script that performs a certain
     analysis and we want to run it on our computer
     
* We will run into an error and fix it

* We run the analysis, save the results and end the session.

* (I'll add here later a YouTube Video that will demonstrate the same steps.)

---

## Where to get help?

* For each function in R exists a help file, that can be accessed with `?`
  This means, in order to get the help for the function foo type `?foo` into the console.

* If you forgot a function name but have a wild guess how it was, the `apropos()` command is usefull.
  In order to check for all commands that contain the word ’test’ type `apropos("test")`.

* Of course Google is always a good place to search 

* A very helpful online ressource is also http://www.stackoverflow.com


---

## A typical workflow in R

1. Open the data with a (good...) text editor or Excel and inspect its properties:

  a. Is the first line a _header-line_?

  b. What is the separator between the columns?

2. Import the data to R

3. Apply some data transformation and calculate desired statistics

4. Visualize the results

5. Store all results

--- .segue .dark

## Import Data to R

---

## Working directory I

* The term ’working directory’ refers in R to the place on the hard drive, where R looks for files, stores Figures etc.

* All paths and filenames that are given relative to this specific location.

* Of course it is possible to check and change this location. 

* A typical workflow of a project is that in the beginning the working directory is set to the project folder on the hard drive.

* The command to check the working directory is `getwd()` and the one for setting it is `setwd()`.

---

## Working directory II

* An example how the working directory is extracted and set using windows:

```{r wd, eval=FALSE}
getwd()
> [1] "C:/Program Files/R/R-3.0.2"
setwd("C:/temp/")
getwd()
> [1] "C:/temp"
```

* The file system is a bit different in Linux, a typical path looks there like
/home/ejo123/myProjects.

---

## Import ASCII files I

* Datasets that are imported to R are typically given in ASCII format. .

* Other formats are possible, but I'd recommend to stay with ASCII/text files.

ASCII is a plain text format and common file extensions are .txt or .csv. Before reading
files into R it is advisable to open them first with a text editor in order to
check the properties of the files. One should focus especially on the
following things:

1. What is the column separator (Whitespace, comma, tab, etc.)?

2. Is the first line a data line or does it contain the variable names?

3. Are real numbers given with comma or point (e.g. is it 5,25 or 5.25)?

4. How is missing data encoded (e.g. NA, dot, whitespace)?

---

## Import ASCII files II

In order to read an ASCII file to R, we perform the following steps:

1. Set the working directory to the path where the data is located.

2. Check for above mentioned properties

3. Read the data and assign it to an object. The command is

```{r , eval=FALSE}
myData <- read.table(file="theData.txt", header=FALSE, sep="\t")
```

In this case the first line contained already data (If the first line are the
variable names, the option is `header=TRUE`) and the columns are
separated with TAB (\t is the so-called escape-seqence for TAB, other
separators are usually given as they are.)

---

## Import ASCII files III

Overview of important import options in `read.table()`:

* `sep` What is the column separator? Typical values are: `","`, `";"`, `" "`, `"\t"`

* `header` Logical, contains the first row variable names or not? Possible values:`TRUE`, `FALSE`

* `na.string` How are missing values encoded in the ASCII file? Typical values: `NA`, `"."`
  Internally in R, they are always encoded as `NA`.

* `dec` What is used as decimal symbol?

* `as.is` Logical, shall R try to predict the ’right’ data format?

* `colclasses` Vector of predefined column classes.

* `stringsAsFactors` Logical, handle strings as factors?

---

## Import ASCII files IV

The `read.table` command is a function that is very user-friendly and that handles most standard data formats.

However, in situations when the data is not in an easy-to-access format, the command `scan()` might be usefull to
read-in such data.

Another useful command is `readLines()` that reads in Line-by-Line.


---

## Import other files to R

Other file formats can also be imported to R, but it usually requires more
efforts.

There are functions that read, e.g. Excel tables, but it is not very
advisable to use them, as those data formats are usually proprietary and
hence developers cannot provide full functionality. The easiest way to
import an Excel sheet to R is to open it with Excel, save it as csv file
and proceed as above mentioned.

Another way to import data is to connect directly to a MySQL database,
but this is above the scope of the course and will be discussed in an
advanced course.

Also, html pages can be access directly (e.g. data download directly from wikipedia and such things.)

---

## Example data

* You can download example data from here:
   [Titanic-data](https://raw.githubusercontent.com/fischuu/fischuu.github.io/master/lectures/IntroductionToR/data/titanic3.csv)
   [stressEcho](https://raw.githubusercontent.com/fischuu/fischuu.github.io/master/lectures/IntroductionToR/data/stressEcho.csv)

* Just Right-click, choose 'Save as' and store them on your HDD.

* These datasets we will use throughout the whole course to learn the different methods.

"Data obtained from [http://biostat.mc.vanderbilt.edu/DataSets] (http://biostat.mc.vanderbilt.edu/DataSets)".

* The Datasets contain plenty of variables, we won't use all of them.

---

## Titanic passenger information variables:

1. pclass (Passenger class)
2. survived (yes=1, no=0)
3. name 
4. sex (female/male)  	
5. age 
6. sibsp	(Number of Siblings/Spouses Aboard)
7. parch	(Number of Parents/Children Aboard)
8. ticket	(Ticket Number)		
9. fare	(Passenger Fare	British Pound)
10. cabin	(Cabin number)		

---

## Titanic passenger information variables (continued):

11. embarked	(S, Q, C=)
12. boat			
13. body	Body Identification Number		
14. home.dest	Home/Destination



---

## Stress echo data

1. bhr	Basal heart rate	(bpm) integer
2. basebp	Basal blood pressure	mmHg integer
3. basedp	Basal Double Product bhr TIMES basebp	 bpm TIMES mmHg	integer
4. pkhr	Peak heart rate	mmHg	integer
5. sbp	Systolic blood pressure	mmHg integer
6. dp	Double product pkhrTIMESsbp	bpm TIMES mmHg integer
7. dose	Dose of dobutamine given	mg	integer
8. maxhr	Maximum heart rate	bpm	integer
9. pctMphr	Percent maximum predicted heart rate achieved	%	integer
10. mbp	Maximum blood pressure	mmHg integer
11. dpmaxdo	Double product on max dobutamine dose	bpm TIMES mmHg integer
12. dobdose	Dobutamine dose at max double product	mg	integer
13. age	Age	years	integer

---

## Stress echo data (continued)

14. gender 2 character
15. baseEF	Baseline cardiac ejection fraction	%	integer
16. dobEF	Ejection fraction on dobutamine	%	integer
17. chestpain	Chest pain		integer
18. restwma	Resting wall motion abnormality on echocardiogram		integer
19. posSE	Positive stress echocardiogram		integer
20. newMI	New myocardial infarction		integer
21. newPTCA	Recent angioplasty		integer
22. newCABG	Recent bypass surgery	integer
23. death			integer
24. hxofHT	History of hypertension		integer
25. hxofDM	History of diabetes		integer
26. hxofCig	History of smoking		3 integer

---

## Stress echo data (continued)

27. hxofMI	History of myocardial infarction		integer
28. hxofPTCA	History of angioplasty		integer
29. hxofCABG	History of coronary artery bypass surgery		integer
30. any.event	Death, newMI, newPTCA, or newCABG		integer
31. ecg	Baseline electrocardiogram diagnosis		3 integer


--- 

## Hands-on: Import the Example data

1. After having downloaded the titanic data, import it to R and name it `titanic`

2. After having downloaded the stress echo data, import it to R and name it `stress`



(If you have your own data, try it to import it to R and give it a reasonable name)

---

## Hint

1. Open the file in a text editor (if you use Word, DON'T save it). I suggest to install Notepad++ and use this as a text editor instead of Notepad ord Wordpad

2. Check the first line, is a header present or not?

3. How are the different cells separated?

---

## Solution: Import the Titanic data

```{r eval=FALSE}
setwd("/home/ejo138/Projects/lectures/IntroductionToR")
titanic <- read.table("titanic3.csv", sep=",", header=TRUE)
stress <- read.table("stressEcho.csv", sep=",", header=TRUE)
```
```{r echo=FALSE}
titanic <- read.table("data/titanic3.csv", sep=",", header=TRUE)
stress <- read.table("data/stressEcho.csv", sep=",", header=TRUE)
```

---

## The R workspace I

As already mentioned now several times, everything is considered to be an
object in R. These objects are living in the so-called workspace. The
workspace in R is comparable with a desk. The content of this
workspace/desk can be shown with the command

```{r, comment=NA}
ls()
```

The `ls()` command shows all active R objects, unneeded objects can be
removed via `rm()` command. Assuming we have an object foo we can
remove it be typing
```{r eval=FALSE}
rm(foo)
```
and all objects of a workspace can removed by (DANGEROUS!!!)
```{r eval=FALSE}
rm(list=ls())
```

---

## The R workspace II

One can store the entire workspace and restore it later on. For that are the
commands `save.image()` and the `load()`command available.
If one want to save a workspace the command is
```{r eval=FALSE}
save.image(file="myRsession.RData")
```

Note that RStudio usually saves the workspace when quitting the session.

One can load the workspace via

```{r eval=FALSE}
load(file="myRsession.RData")
```

This is especially then usful when one works on different projects where the calculations
take a while and cannot be easily repeated.

---

## How to continue

* After importing the data to R, the first step is to check if the data was imported properly!

* It is a common source of error to import the data wrongly without noticing it in the first place!

* But how to check if the data was imported properly? For that some background of R's data types and data structures is needed.

* Each (data) object in a programming language is of a certain type and is handled different.

* R knows basically 5 different data types:

1. The empty set. Example: `NULL`. Name: NULL.
2. Logical values. Example: `TRUE`. Name: logical.
3. Real values. Example: `3.13` or `4`. Name: numeric.
4. Complex values. Example: `5.22+1i`. Name: complex.
5. Letters and strings. Example: `"Hei hei"`. Name: character.

--- .segue .dark

## Data structures

---

## Standard data formats I

* In R everything is an object.

* Although R isn't a classical object orientated programming language, we use this term here.

* Values can be stored in variables.

* Variables can be of very different type and have very different properties, depending on the purpose for what we need them!

* Also functions return objects (also here are different types possible).

* __Question__: What for do I need these variables and how do I use them?!

---

## Standard data formats II

The standard data objects for numbers (numeric) and strings (character) are

1. `vector`
2. `matrix` or `data.frame`
3. `list`
4. `array`
5. `factor`
6. `(function)`

* Each data structure has it’s own properties and we are going through them soon.

* The main idea of a data structure is to store the previous result and make it later accessible!

---

## Data structure: Vector

* The vector structure is similar to vectors known from mathematics.

* You can compare vectors with houses along a street.

* There is clearly defined how many houses there are (= length of the vector).

* Each house has it’s clear position that can be addressed.

* The only difference is, at each postion only one element is allowed and all elements have to be the same type. (This is then the difference to a real street, hopefully!)

---

## Data structure: Vector II

* A vector in R is a sequence of elements that have all the same mode. 

* The easiest way to create a vector is using the `c()` function. 

* The function is used as follows:

```{r eval=FALSE}
vectorname <- c(value1, value2, ...)
```

* A single number is also treated like a vector but can be easier assigned to an object:
```{r eval=FALSE}
vectorname <- value1
```

---

## Data structures: Vector III

* Let’s assign some values:
```{r}
 peter.height <- 190
 paul.height <- 188
 kati.height <- 179
```

* These are now special type of vectors, because they have just length 1! 

* Let’s combine now these special vectors:

```{r}
all.height <- c(peter.height, paul.height, kati.height)
heights <- c(190, 188, 179)
```

---

## Data structures: Vector IV

* Just by typing the name of an object (here the vector) into the console, R displays its content.

```{r comment=NA}
all.height
heights
```

---

## Data structure: Vector V

* As mentioned in the street example, each position in a vector can be
addressed:
```{r comment=NA}
 heights[1]
 all.height[3]
```

We can also see the length of a vector:

```{r comment=NA}
length(heights)
```

---

## Data structure: matrix I

* The matrix structure is also similar to matrices known from mathematics.

* You can compare them with a chessboard.

* There is clear defined how many fields there are (= 'product of the edges').

* Each cell has it’s clear position that can be addressed.

* The only difference (to a chessboard...) is also here all elements have to be the same type and it can be rectangular, with arbitrary sizes.

---

## Data structure: matrix II (create matrices)

* Matrices are filled using vectors:

```{r comment=NA}
 myMatrix <- matrix(c(1,2,3,4,5,6), ncol=3)
 myMatrix
 myMatrix2 <- matrix(c(1,2,3,4,5,6), ncol=3, byrow=TRUE)
 myMatrix2

```

---

## Data structure: matrix III (get dimensions)

```{r comment=NA}
 nrow(myMatrix)
 ncol(myMatrix)
 length(myMatrix)
 dim(myMatrix)
```

---

## Data structure: matrix IV

* In order to access specific elements in a matrix, we have to give 2 positions, or the column/row number of interest

```{r comment=NA}
 myMatrix[1,3]
 myMatrix[2,]
 myMatrix[,1]
```

---

## Data structure: matrix V

We can also change certain entries in the matrix

```{r comment=NA}
 myMatrix[1,3] <- 100
 myMatrix
 myMatrix[1,] <- c(5,9,2)
 myMatrix
``` 

---

## Data structure: matrix VI

We can also change certain entries in the matrix

```{r comment=NA}
 myMatrix[,2] <- c(7,3)
 myMatrix
```

---

## Interruption

It is already time to review some things that happened here!

1. We saw that basically everything happened by using functions. The general syntax was:

```{r eval=FALSE}
Functionname(Argument)
```

2. We saw also that all functions return objects, e.g. the command to
get the number of rows of matrix `nrow()` gives a vector of length 1
with the result.

3. As a special command we had the `matrix()` command. Maybe you
have noticed that it took 2 arguments as input! These arguments
have been separated by comma and we will see this more frequent in
the future!

---

## Hands-On: Assigning values

1. Assign values 4, 6 and 12 to the object `test`
2. Change the second element of `test` then to 14
3. Create a matrix testMat that looks like this:

```{r echo=FALSE}
testMat <- matrix(c(5,6,3,12), ncol=2)
```
```{r comment=NA}
testMat
```

4. Display the second column of the matrix testMat

---

## Hands-On: Solutions 1&2

1. Assign values 4, 6 and 12 to the object `test`

```{r comment=NA}
 test <- c(4,6,12)
 test
```

2. Change the second element of `test` then to 14

```{r comment=NA}
 test[2] <- 14
 test
```

---
## Hands-On: Solutions 3&4

3. Create a matrix testMat that looks like this:

```{r comment=NA}
 testMat <- matrix(c(5,3,6,12),ncol=2)
 testMat
```

4. Display the second column of the matrix testMat

```{r comment=NA}
 testMat[,2]
```

---
## Different data types in a vector
So far we introduced vectors and matrices but used numbers in it. Well,
what about text?! In categorical data text objects are commonly used,
different sequences might be non-numerical coded, gene names, etc.
Text (or better ’strings’) are identified with quotations:
```{r comment=NA}
 myString <- "Peter Pan"
 myString
```
 
But what happens now, when we combine strings and numbers?!
Remember, I said earlier, in matrices and vectors are only same object
types allowed.

```{r comment=NA}
myNewString <- c(myString,"Robin Hood",123)
myNewString
```

---

## Data structure: data.frame I

One data structure that overcomes the limitation that all elements have to
be of the same class is the data.frame:

```{r comment=NA}
 myDF <- data.frame(height = c(190, 187, 178),
                    name = c("Peter", "Paul", "Kati"))
 myDF
```

---
## Data structure: data.frame II

data.frame are practically vectors of same length that are organized in a matrix similar shape.

```{r comment=NA}
 myDF[,1]
 myDF[,2]
```

---

## Data structure: factor I

We saw already the next type of data structure / type: the factor
type. It is especially used for categorical data or status information like
male / female, placebo / drug. etc.
Possible values are called here levels. All levels from such a data
structure can then be shown via

```{r comment=NA}
 levels(myDF[,2])
```

One has to be very careful with factors, as they might behave not in such
a way as one would always assume! They are highly controversial, some R-users
love them, some hate them, and some accept them.

Depending on your tasks, `factors` can be extremly helpful or be the source of
error. By default, R imports all `strings` as `factor`. It is adviceable to
make your own experciences, if you like them or not.

---

## Data structure: factor II

By default R interprets strings as factors. This behaviour can be changed
using the additional option stringsAsFactors:

```{r comment=NA}
 myDF <- data.frame(height = c(190, 187, 178),
                   name = c("Peter", "Paul", "Kati"),
                   stringsAsFactors=FALSE)
 myDF
```

---

## Data structure: factor II

```{r comment=NA} 
 myDF[,1]
 myDF[,2]
```

---

## Our data example

* Lets come back to our data example.

* Earlier we imported the two datsets `titanic` and `stressEcho`.

* Back then we said we have to check, if they have been properly imported, we can do this now!

```{r, comment=NA}
 stress[1:6,1:12]
```

---

## Our data example: (structure)
```{r, comment=NA}
 str(stress)
```

---

## Our data example (summary)
```{r, comment=NA}
 summary(stress)
```


## Naming of element
* Columns of data.frames can have names that can be accessed with the $ sign.

* Names were taken from the `header`line in the data import step via `read.table`.

* We did the same already earlier, when we had the data.frame. It works there the same way:

* Lets check the first 25 elements of the column named `bhr` in the data.frame `stress`:

```{r, comment=NA}
 stress$bhr[1:25]
```

---
## Getting the column names of a data.frame

* There are commands to set and get the column names of a matrix or data.frame.

* This is called `colnames()`:

```{r, comment=NA}
 colnames(stress)
```

---
## Summary break

* It is again time to review some things that happened here!

1. We saw that R might change the data type by itself!
2. These changes are not visible on the first view.
3. We don’t have to panic! The previously introduced concepts will soon be intuitively to use.

* What can we do already?!
1. We can write values into variables (using <-).
2. We can access values from variables (using [,]).
3. We know that there are different data types (numerical and strings).
4. We can give names to columns.

---
## Hands-On: Titanic data

1. Check if you imported the dataset `titanic` properly
2. Print the column with the names of the passengers

---
## Hints: Titanic data

1. Use `str()` and the square brackets `[]`
2. Use the `$` sign, once you know how the column is called.

---
## Solutions: Titanic data

1. Check if you imported the dataset `titanic` properly

```{r comment=NA}
str(titanic) 
```

---

## Solutions: Titanic data II

2. Check if you imported the dataset `titanic` properly

```{r comment=NA}
titanic$name
```

---

## data structure: list I

* So far we had all kind of data structures that are more or less known from mathematics.

* But what if we want to combine elements that do not have same dimensions?

* A list fulfills such a purpose, and it ’sits on top’ of the previous introduced structures.

* Think of a list as a necklace: pearls are sequentially, but can be completely different. Some necklaces have even big constructions
  hanging in between. All this is also possible by using lists.

* In order to read/write into a list, we need double square brackets `[[ ]]`

---

## Data structure: list II

An example of an list:

```{r comment=NA}
 rooms <- c("F001","F002","F003")
 building <- c("Datum","Alimentum")
 someData <- matrix(c(1,2,3,4),ncol=2)
 myList <- list(rooms, building, someData)
```

---

## Data structure : list III

```{r, comment=NA}
 myList
```

---

## Data structure : list IV
Accessing the second element of the list `myList`:
```{r, comment=NA}
 myList[[2]]
```

Printing the vector `building`:
```{r, comment=NA}
 building
```

---

## Named elements in the list

* Now we combine the elements not only by putting them into a `list()` command.

* At the same time we will give them names:

```{r comment=NA}
 rooms <- c("F001","F002","F003")
 building <- c("Datum","Alimentum")
 someData <- matrix(c(1,2,3,4),ncol=2)
 myList2 <- list(TheRooms=rooms, build=building, data=someData)
```

---

## Data structure : list III

```{r, comment=NA}
 myList2
```

---

## Data structure : list IV
Accessing the second element of the list `myList`:
```{r, comment=NA}
 myList2[[2]]
```

Printing the column called `build`:
```{r, comment=NA}
myList2$build
```

---

## Data structure: list V

* It is very important to understand the concept of a list in R, as it is a commonly used structure.

* Many functions report back the results in form of lists.

* A typical example is a statistical test that reports then e.g. back:

  1. Value of the test statistic ($statistic)
  2. P-value ($p.value)
  3. Confidence intervall ($conf.int)
  4. etc


--- .segue .dark

## R as pocket calculator  

---

## R as pocket calculator

It is easy to use R as a basic pocket calculator
```{r comment=NA}
1+2*3
2*5^2 - 11
sqrt(9)
cos(2*pi)
```

---

## R as pocket calculator II

Table 1: Basic arithmetic functions in R

Command       |  Explanation
--------------|---------------------------
`^` or `**`   |  Power
`*`, `/`      |  Multiplication, Division
`+`, `-`      |  Addition, Subtraction
`%/%`         |  Integer Division
`%%`          |  Modulo Division

---

## R as pocket calculator II

Table 2: Basic functions in R

Command            |  Explanation
-------------------|---------------------------
`max()`, `min()`   |  Maximum, minimum
`abs()`            |  Absolute value
`sqrt()`           |  Square root
`round()`,`floor()`,  `ceiling()`  |  Rounding
`sum()`, `prod()`  |  sum, product
`log()`            | Logarithm
`exp()`            | Exponential function
`sin()`, `cos()`   | Trigonometric functions

---

## Perform basic calculations

* Now after we know what basic data types and structures are available, what can we do with them!?

* We saw already that R can be used as simple pocket calculator, so what happens when you do the same with the other data structures?
 (Remember, a single value is considered to be a vector of length 1!)

```{r comment=NA}
 x <- c(1,2,3,4,5,6,7,8,9,10)
 x*2
```

* R works vector-based. This means, the 2 is internally repeated so many times, that the length of the vectors match, like this:
```{r comment=NA}
x <- c(1,2,3,4,5,6,7,8,9,10)
x*c(2,2,2,2,2,2,2,2,2,2)
```

---

## Perform basic calculations II

Table 3: Basic functions in R

Command            |  Explanation
-------------------|---------------------------
`mean()`, `median()` |  Mean, median
`sd()`, `var()`    |  Standard deviation, variance
`min()`, `max()`   |  Extreme values
`range()`          |  Both extreme values
`sort()`           |  Sort a vector

---

## Handling missing data

* R denotes missing data usually with `NA`.

* Missing data is a pain for most calculations, as it is not clear how to handle it!

* Most function provide options to define how to handle missing data:

```{r comment=NA}
x <- c(4,3,2,NA,78)
mean(x)
mean(x, na.rm=TRUE)
```

---

## Hands-On Pocket Calculator

Calculate:

1. Square root of 15
2. Absolute value of -5 multiplied by 4
3. 4 to the power of 5
4. 21 modulo 5
5. Integer division of 21 by 5
6. Rounded product of 4 and 5.16

---

## Solutions: Pocket Calculator 1-3

1. Square root of 15
```{r comment=NA}
 sqrt(15)
```
2. Absolute value of -5 multiplied by 4

```{r comment=NA}
 abs(-5)*4
```
3. 4 to the power of 5
```{r comment=NA}
 4^5
```

---

## Solutions: Pocket Calculator 4-6

4. 21 modulo 5
```{r comment=NA}
 21%%5
```
5. Integer division of 21 by 5

```{r comment=NA}
 21%/%5
```
6. Rounded product of 4 and 5.16
```{r comment=NA} 
 round(4*5.16)
```

---

## Hands-On: Example data

1. Calculate the mean age of the Titanic passengers
2. How many passengers survived the Titanic tragedy?
3. What is the smallest/largest basic heart rate in the stress data?
4. What is the Standard deviation of the Age in the stress data?

---

## Hints: Example data

1. Use the `mean()` function. Columns you can access with `$` or with `[]`.
2. People who survived are encoded as 1. A sum over the corresponding column gives the total amount.
3. You could use either `min()`/`max()` or `range()` on the column `bhr`.
4. The required function is called `sd()`.

---

## Solutions: Example data I

1. Calculate the mean age of the Titanic passengers
```{r comment=NA}
mean(titanic$age, na.rm=TRUE)
```

2. How many passengers survived the Titanic tragedy?
```{r comment=NA}
sum(titanic$survived)
```

---

## Solutions: Example data II

3. What is the smallest/largest basic heart rate in the stress data?
```{r comment=NA}
range(stress$bhr)
```

4. What is the Standard deviation of the Age in the stress data?
```{r comment=NA}
sd(stress$age)
```

---

## Sequences and repetitions I

* Often we are interested in sequences and repeated values - and writting them by hand is laborious.

* The commands `rep()`, `seq()` and `:` make the life easier:

```{r comment=NA}
x <- seq(from=1, to=10, by=1)
x
1:10
```

---

## Sequences and repetitions II

Especially the rep command is very powerful:

To simply repeat a single value, the `times` argument can be used

```{r comment=NA}
rep(2, times=10)
```

The same option can also repeat whole vectors

```{r comment=NA}
rep(c(1,2), times=3)
```

---

## Sequences and repetitions III
Further, single elements of a vector can be repeated with the `each` option
```{r comment=NA}
rep(c(1,2), each=3)
```

And finally, elements of a vector can be repeated individually

``` {r comment=NA}
rep(c(1,2), times=c(3,4))
```

---

## Recycling of vectors

The internal repetition to make vectors fit for arithmetic operations is called in R ’recycling’.

```{r comment=NA}
x <- 1:10
x*c(1,2)
x*c(1,2,3)
```

---

## Logical operators in R I 

Table 5: Logical Operators in R

Command       |  Explanation
--------------|---------------------------
`==`          |  equals
`!=`          |  unequal
`<`           |  smaller
`<=`          |  smaller or equal
`>`           |  larger
`>=`          |  larger or equal
`!`           |  NOT
`&`           |  AND
`\|`            |  OR
`TRUE`        |  true 
`FALSE`       |  false

---

## Logical operators in R - example

Print the first 20 elements of the `basebp` column:

```{r comment=NA}
stress$basebp[1:20]
```
Now check, which of those is larger than 150:
```{r comment=NA}
stress$basebp[1:20]>150
```

---

## Combine logic operators

One can combine logical operations, e.g. basebp larger than 150 and male:
```{r comment=NA}
(stress$basebp[1:40]>150) & (stress$gender[1:40]=="male") 
```

One can even use the logical output to access rows/columns of a data.frame:
```{r comment=NA}
stress[(stress$basebp>190) & (stress$gender=="male"), c(1:7,15,16)]
```

---

## Working on data.frames (`subset()`)

```{r comment=NA}
small <- subset(stress,select=c(bhr,age,gender,ecg))
small[1:4,]
```

---

## Working on data.frames
```{r comment=NA}
# aggregate numeric to (ordered) factor
small$agegrp <- NA
small$agegrp[small$age<=40] <- 'young'
small$agegrp[small$age>40 & small$age<=60] <- 'medium'
small$agegrp[small$age>60] <- 'old'
small[1:8,]
```

---

## Working on data.frames

```{r comment=NA}
small$agegrp <- ordered(small$agegrp,levels=c('young','medium','old'))
table(small$gender,small$agegrp)
```

---

```{r comment=NA}
# means or sums of all variables (in purely numeric data frame)
numdata <- stress[, 1:3]
colMeans(numdata)
# sorting of data frame
small.ordered <- small[order(small$age,small$bhr),]
head(small.ordered,20)
```

---

## Hands on: Sequences, Recycling and Logic

1. Create a vector with elements `2,4,6,8,...,100` and calculate the mean of it.
2. Get from that vector all elements that are larger than 80.
3. Extract every 10th row from the `titanic` data set
4. How many individuals in the `stress` data are older than 70?
5. Count the female / male survivors on Titanic

---

## Hints: Sequences, Recycling and Logic

1. Use the `seq()`command with `from`, `to` and `by` options
2. Use the logic operator with the square brackets `[]` to access the right elements.
3. Create first the required sequence with `seq()` and then plug it into the square brackets `[]`
4. Use the logic operator on the `age` column and then make use of thefact that `TRUE` counts as 1 and `FALSE` counts as 0.
5. Use the logic operator on the `sex` column and plug this into the `survivor` column - then proceed as in the earlier Hands on exercise

---

## Solutions: Sequences, Recycling and Logic I

1. Create a vector with elements `2,4,6,8,...,100` and calculate the mean of it.
```{r comment=NA}
 x <- seq(from=2, to=100, by=2)
 x
```

2. Get from that vector all elements that are larger than 80.
```{r comment=NA}
x[x>80]
```

---

## Solutions: Sequences, Recycling and Logic II

3. Extract every 10th row from the `titanic` data set (output truncated)
```{r comment=NA, eval=FALSE}
titanic[seq(10,1300,10),]
```
```{r comment=NA, echo=FALSE}
titanic[seq(10,110,10),c(1,2,4:10)]
```

---

## Solutions: Sequences, Recycling and Logic III

4. How many individuals in the `stress` data are older than 70?
```{r comment=NA}
sum(stress$age>70)
```

5. Count the female / male survivors on Titanic
```{r comment=NA}
sum(titanic$survived[titanic$sex=="female"])
sum(titanic$survived[titanic$sex=="male"])
```

--- .segue .dark

## R-Packages

---

## Packages on Cran I

* R comes with a lot of basic functionality, but there are plenty of applications that cannot be covered from the core system.
* In order to extend the functionality of R there is a package system where user can provide their own functions for other users.
* The quality differs a lot between different packages, there are very rudimental packages and very sophisticated available.
* Currently there are about 5000 packages available and there is an overview here:

[Available packages](http://cran.r-project.org/web/packages/available_packages_by_name.html)

---

## Packages on Cran II

* In order to use packages they first have to be installed. 
* In most R editors there is a graphical menu to do that, otherwise there is a command `install.packages()` available.
* Once a package is installed the functionality can be loaded with the `library` command.
* Many packages contain besides functions also dataset that can be used to test the functions of it.

* To install and load a package (e.g. `MASS`) one can type

```{r eval=FALSE}
install.packages("MASS")
library("MASS")
```

* `library(help="MASS")` provides some additional package information

---

## Some useful R packages 

Table 6: Useful R packages

Command       |  Explanation
--------------|---------------------------
`foreign`          |  Functions that help to import SAS or SPSS datasets
`dplyr`          |  Helpful functions for data manipulation
`ggplot2`           |  Famous package for easier graphics
`googleVis`          |  Use Google Chart tools to visualize data
`lme4`           |  Linear mixed-effects models
`survival`          |  Tools for survival analysis
`randomForest`           | Random forest method for machine learning
`data.table`           |  An alternative way to organize large data set

---

## Hands on: Packages

1. Install the package `foreign`
2. Install the package `randomForest`
3. Load both packages into the workspace

---

## Solutions

1. Install the package `foreign`
```{r eval=FALSE}
install.packages("foreign")
```

2. Install the package `randomForest`
```{r eval=FALSE}
install.packages("randomForest")
```

3. Load both packages into the workspace
```{r eval=FALSE}
library("foreign")
library("randomForest")
```

--- .segue .dark

## EDA and Plots

---
  
## Explorative data analysis

After importing a dataset and verifying that everything went fine with the import, one usually starts
to explore the dataset in order to get 'a feeling' for it.

This usually involves to calculate some key location statistics (mean, median, quantiles) as well as first, basic visualizations.

Common visualizations are 'Scatterplots' and 'Boxplots'

The commands we will use for the first EDA steps are `summary()`, `boxplot()`, and `plot()`

---

## `summary()` command

The easiest way to get a first impression of the data is to use the `summary()`command. 

It gives us the 5 point (plus mean) summary of a vector. 

We apply the function onto the `stress$bhr` data:

```{r comment=NA}
summary(stress$bhr)
```

---

## The `boxplot()` command I

The boxplot is more or less a graphical representation of the 5 point summary (only the whiskers are not neccessary part of the 5 points summary)

In a boxplot the thick inner line represents the _median_.

The boundaries of the box represent the upper and lower quartile / 25% and 75% quantile. Consequently, the box represents the 'inner 50% of the data'.

The whiskers mark those two values that differ at most 1.5 times the inner quartile range (IQR) from the median.

All values that are further away are marked individually with circles

---

## The `boxplot()`command II

```{r}
boxplot(stress$bhr)
```

---

## The `plot()` command I

* The `plot()` command is rather an universal function in R.

* Depending on the input, the output can be entirely different.

* The reason for this is that many objects in R are associated with their own `print()`, `summary()` or `plot()`

* We saw already, a numerical vector has a 5-points table as output of a `summary()`, but also this can be different for other objects.

* The most basic usage of `plot()` is to either feed one or two vectors in it.

* In these situations, the `plot()` function creates by default a scatterplot.

---  &twocol w1:50% w2:50%

## The `plot()` command II

```{r eval=FALSE}
plot(stress$bhr)
```

*** =left

```{r echo=FALSE}
plot(stress$bhr)
```


***=right

Here, only one vector is provided. 

Its values are considered to be the values on a y-axis.

The x-axis values are automatically added and the index number is used.


---  &twocol w1:50% w2:50%

## The `plot()` command II

```{r eval=FALSE}
plot(stress$maxhr,stress$bhr)
```

*** =left

```{r echo=FALSE}
plot(stress$maxhr,stress$bhr)
```


***=right

Now two vectors are provided.

They need to be of the same length, as pairs $(x_i,y_i)$ are formed.

The first vector represents the x-axis values, the second one the y-axis.

---  &twocol w1:50% w2:50%

## The `plot()` command III

```{r eval=FALSE}
plot(bhr~maxhr, data=stress)
```

*** =left

```{r echo=FALSE}
plot(bhr~maxhr, data=stress)
```


***=right

Using formula notation and the `data` argument

---

## Further reading on R graphics

* You find on Paul Murrells page [here](https://www.stat.auckland.ac.nz/~paul/RG2e/) a nice online resource for R graphics

* A very popular R package for graphics is the `ggplot2` package, but it goes over the scope of this course to explain its functionality

* [Here](http://r4stats.com/examples/graphics-ggplot2/) you can find some examples how ggplot2 works / looks like.

--- &twocol w1:50% w2:50%

## Density estimators

```{r eval=FALSE}
plot(density(titanic$fare, na.rm=TRUE))
```

*** =left

```{r echo=FALSE}
plot(density(titanic$fare, na.rm=TRUE))
```


***=right

Visualizing the density estimator is also a good example for nested functions.

First, the density estimator is calculated and then feeded into the plot function that visualizes it then.

--- &twocol w1:50% w2:50%

## Empirical Cumulative Density function

```{r eval=FALSE}
plot(ecdf(titanic$fare))
```

*** =left

```{r echo=FALSE}
plot(ecdf(titanic$fare))
```


***=right

Also the visualization of the empirical cumulative Density function can be written as a nested function.
---

## Hands-On

1. Prepare the 5 Point summary for the fares in the `titanic` data

2. Create the boxplot of the age of the Titanic passengers

3. Plot the ticket price versus the age of the passenger.

4. Plot the density estimator for the age on the Titanic

5. Plot the ecdf of the age on Titanic

---

## Solutions:

1. Prepare the 5 Point summary for the fares in the `titanic` data

```{r}
summary(titanic$fare)
```

---

2. Create the boxplot of the age of the Titanic passengers

```{r}
boxplot(titanic$age)
```

---

3. Plot the ticket price versus the age of the passenger.

```{r}
plot(titanic$fare, titanic$age)
```

---

4. Plot the density estimator for the age on titanic

```{r}
plot(density(titanic$age, na.rm=TRUE))
```

---


4. Plot the empirical cumulative density function for the age on titanic

```{r}
plot(ecdf(titanic$age))
```

---

--- .segue .dark

## Statistical models in R

---

## Statistical models in R

Summary statistics give only a glimpse at the data and often an analysis of
inference and or modeling is the actual goal. R provides a lot of statistical
tests as well as a lot of modeling functions. Before we can, however, use
them we have to learn something about R’s formulae definitions to be able
to define models in R. A basic formula in R has the form
```{r eval=FALSE}
y ~ x1 + x2 + x3
```
where the part left of the tilde is the dependent variable and the right part
defines the independent variables.

---

## Statistical models in R

The intercept in a model formula is represented by a 1. By default R
assumes that an intercept is present, therefore mentioning the intercept or
not makes no difference. If however the intercept should be removed a -1
is needed in the formula.
These two models are equivalent, both have an intercept:
```{r eval=FALSE}
y ~ x1 + x2 
```
and
```{r eval=FALSE}
y ~ x1 + x2 + 1
```
the same model without intercept must be defined as:
```{r eval=FALSE}
y ~ x1 + x2 - 1
```

---

## Interaction and nested design

Often in statistical models interactions between variables are suspected or
variables are nested. This can be formulated also using R formulae.
Several special operators are available for this. To name a few:
* `:` Used for interactions like `x1:x2`
* `*` Main effects plus interactions, like `x1*x2 = x1 + x2 + x1:x2`
* `^` Factor crossing up to a certain degree, like
`(x1+x2+x3)^2 = x1+x2+x3 + x1:x2 + x1:x3 + x2:x3`
* `-` Removing terms, like
`(x1+x2+x3)^2 - x2:x3 = x1+x2+x3 + x1:x2 + x1:x3`



---

## Variable transformation in formulae

Common practice is to use tranformations of variables in statistical models.
This can be done in R directly in the model formula. For example:
```{r eval=FALSE}
log(y) ~x1 + x2 + sin(x3)
```
However, due to the definition of interactions, the special function I is of
interest here. This function interprets the operators used inside it as
expressions in their original meaning. For example:
```{r eval=FALSE}
y ~ I(x1-1) 
```
subtracts from x1 one unit before it enters the model
and not the intercept. This is therefore different from `y ~ x1-1`
```{r eval=FALSE}
y ~ I(x1^2) 
```
squares variable x1 and has nothing to do with factor crossing.

---

## Functions for tests and modelling

Now we should have all tools to do statistical tests and model data using
R together.
The following slides will introduce some functions for common tests and
introduce regression model functions in R and how to work with them.
This will basically be a list of functions. For tests the function for t-tests is
considered in more detail and for regression models the function for linear
regression models.

---

## Tests for numeric data in R

Table 6: Tests for location and scatter in R

Command       |  Explanation
--------------|---------------------------
`t.test()`          |  One and two sample t-test
`cor.test()`          |  Correlation test
`var.test()`           |  F-test to compare two variances
`bartlett.test()`          |  Bartlett's test for k variances
`wilcox.test()`           |  One and two sample Wilcoxon test
`kruskal.test()`          |  Kruskal-Wallis test
`friedman.test()`           |  Friedman's test
`ks.test()`           |  Kolmogorov Smirnov test

---

## Tests for non-numeric data in R

Table 6: Some other tests in R

Command       |  Explanation
--------------|---------------------------
`binom.test()`          |  Binomial test
`prop.test()`          |  Test to compare proportions
`prop.trend.test()`           |  Chi-square test for trend in proportions
`fisher.test()`          |  Fisher's exact test for 2-dimensional contingency tables
`chisq.test()`           |  Chi-square test for contingency tables


---

## Student's t-test in R I

Student’s t test is used to test in normal populations a hypothesis about
the location or to compare the location of two normal populations. In the
latter case one must furthermore decide if the two populations have the
same variance or not and if the test is based on paired or independent
observations.

All these cases are considered in the function `t.test`. For the one sample
case only a numeric vector has to be submitted and by default the
hypothetical location is the origin. For the two sample case one can submit
either two numeric vectors or a formula where the independent variable is
a factor with two levels. In the two sample case the default setting
assumes that the samples are independent and have different variances.

The alternative of a test usually can be picked via the `alternative` option
in the function call.

---

## Student's t-test - examples

We want to test the following

__$H_0$__: The mean age of the stress data is equal to 65

_vs._

__$H_1$__: Not equal to 65

This means, we perform a _one-sample t-test_.

(Just for our interest, we calculate also the mean-age)
```{r comment=NA}
mean(stress$age)
```

---

## Student's t-test - examples

```{r comment=NA}
t.test(stress$age, mu=65)
```

---

## Student's t-test - examples

```{r comment=NA}
t.test(stress$age, mu=67)
```

---

##  Wilcox test - examples

```{r comment=NA}
wilcox.test(stress$age, mu=65)
```

---

## Wilcox test - examples

```{r comment=NA}
wilcox.test(stress$age, mu=67)
```

---

## Two-sided t-test

Now, we are interested if there is a difference in the Age between the two gender. For this we use
the formulae notation:

```{r comment=NA}
t.test(age~gender, data=stress)
```

---

## Two-sided Wilcoxon test

Again, we could do the same test also with a non-parametrical test

```{r comment=NA}
wilcox.test(age~gender, data=stress)
```

---

## Student's t test examples

The formulae notation might not be intuitive at the first sight. Luckily all
functions accept also a more ’natural’ approach, although this would
require more coding:

```{r comment=NA}
age.male <- stress$age[stress$gender=="male"]
age.female <- stress$age[stress$gender=="female"]
t.test(age.female, age.male)
```

---

## Hands-On : Tests 

1. Test if the ticket prices differed between class 1 and 3 passengers on Titanic.
2. Test if the average age on Titanic was larger than 30 (check the help file of t.test in order to choose the right alternative!).

--- 

## Hands-On: Hints:

1. The formula notation doesn't work here, as there is also class 2 passengers on board. Create first vectors that contain the values of interest

---

## Solutions: Tests

Test if the ticket prices differed between class 1 and 3 passengers on Titanic.
```{r comment=NA}
class1 <- titanic$fare[titanic$pclass=="1"]
class3 <- titanic$fare[titanic$pclass=="3"]
t.test(class1,class3)
```

--- 

## Solutions: Tests

Test if the average age on Titanic was larger than 30
```{r comment=NA}
t.test(titanic$age, mu=30, alternative="greater")
```

---

## Linear regression

Almost all regression functions are called using a formula notation:
```{r eval=FALSE}
foo.reg <- foo(model formula)
```
This object is then usually quite complex and printing it returns only
minimal output. A lot of generic functions have however methods for the
different regression models.

Table 10: Linear regression functions and packages

Function   | Meaning
---------------|----------------
`lm()`  | Linear regression
`aov()`   | ANOVA models in R
`glm()`  | Generalized linear models like logistic regression
`nls()`  | Nonlinear regression
nlme  | Package: Linear and non-linear mixed effect models
survival | Package: Parametric and nonparametric survival models

---

## Linear Regression: Generic functions



Table 11: Generic functions of linear regression

Function  | Meaning
----------|----------------
summary  | Most important output
anova  | ANOVA table
fitted  | Fitted values for the model
predict  | Can be used to predict new observations
resid  | Residuals
plot  | Diagnostic plots
coef  | Estimated parameters

---  &twocol w1:50% w2:50%

## Example: Relation of age and survial on Titanic

```{r eval=FALSE}
boxplot(age~survived, data=titanic)
```

*** =left

```{r echo=FALSE}
boxplot(age~survived, data=titanic)
```

*** =right
First have a look at the function call, boxplots can use also the formula notation, to plot grouped boxplot next to each other!

Looking at the boxplots, the age distribution in the group of survivors (`1`) appears to be similar compared to the non-survivors (`0`)

Shall we stop here?

---

## Linear regression/Cross-tabulation

Instead of checking the age distribution within the two groups survived/non-survived, we could e.g also calculate for each age the ratio
of survival. The easiest way to get it is the crosstabulation. The command `table()`helps us here.

The `table()` command provides a frequency table of a single variable or a crosstable in case two variables are given, e.g.:

```{r comment=NA}
table(stress$hxofCig)
```

---

## Crosstabulation age

First 10 lines of the cross-tabulation age versus survived
```{r comment=NA}
ageSurvTab <- table(titanic$age,titanic$survived)
ageSurvTab[1:10,]
```

---

## Linear Regression on survival rate

It is important to see that the output is again a `matrix`. The column names are the classes of the one variable (`survived`) and the rownames are
the possible classes of the other one (`Age`).

If one goes e.g. to row labeled `3` it means that `2` persons with age 3 haven't survived, but `5` have.

Having this information we can now calculate the survival rate in each age group:

It is just for each age the number of survivors (second column), divided by the amount of people at that age (=rowsum in the age-group)

```{r comment=NA}
survRatio <- ageSurvTab[,2]/(ageSurvTab[,1]+ ageSurvTab[,2])
survRatio[1:7]
```

--- &twocol w1:50% w2:50%

## Visualization of the survival rate in age:
```{r eval=FALSE}
plot(survRatio)
```

*** =left
```{r echo=FALSE}
plot(survRatio)
```

*** =right
Just a basic plot of the age groups. 

Please notice that, instead of the real age groups, there is just the index plotted! This means now, that we actually do not
plot the correct image, but we assume that each value represents one year- and this is not the case!

In truth, we want to plot the names of the table (equals the age group) versus the survival rate.

--- &twocol w1:50% w2:50%

## Visualization of the survival rate in age:
```{r eval=FALSE}
plot(names(survRatio), survRatio)
```

*** =left
```{r echo=FALSE}
plot(names(survRatio), survRatio)
```

*** =right

Here are now some things happening that we do not know, yet! For the sake of completeness: What happens here is 
that the names, which are internally a `character` are casted to be `numerical`. This is a common source of error 
that data seems to be alright, but in truth it isn't.

The `plot` function is, however, clever enough to fix that, but there are many occasions, where functions are dumb
with respect to the class and where the user has to take care of this alone.

---

## Apply a linear regression

We assume now that all assumptions of a linear regression are fulfilled.

To fit a linear model we need to _cast_ the data still:

```{r comment=NA}
class(names(survRatio))
survRatio[1:7]
names(survRatio)[1:7]
```

---

## Casting 

The values are displayed in quotation marks, this means that, although the values look like numbers, they are internally handled as words. This means, you
cannot calculate with them:

```{r comment=NA}
"1"+ "4"
```

We can use the `as.*()` command family to cast between data types:

```{r comment=NA}
"4"
as.numeric("4")
```

---

## Casting `names(survRatio)`

```{r comment=NA}
ageGroup <- as.numeric(names(survRatio))
class(ageGroup)
names(survRatio)[1:7]
ageGroup[1:7]

```

Now we have numerical data and can fit a linear model (remember, if you have already numerical data, you do not have to do the casting!)

---

## Apply a linear model

```{r comment=NA, asis=TRUE}
titanicLM <- lm(survRatio~ageGroup)
titanicLM
```

--- &twocol w1:50% w2:50%

## Visualize the linear model 

*** =left
```{r echo=FALSE}
plot(survRatio~ageGroup)
abline(titanicLM)
```

*** =right 

First just plot the data as you know it already and then add a line with the `abline()`command:

```{r eval=FALSE}
plot(survRatio~ageGroup)
titanicLM <- lm(survRatio~ageGroup)
abline(titanicLM)
```

--- &twocol w1:50% w2:50%

## Non-linear fitting 

*** =left
```{r echo=FALSE}
plot(survRatio~ageGroup)
loessCurv <- loess(survRatio~ageGroup)
lines(predict(loessCurv), col="red", lwd=2)
abline(titanicLM)
```
*** =right

Without going into too many details, we want to see how easy one could switch from a linear regression to a non-linear LOESS.

```{r eval=FALSE}
plot(survRatio~ageGroup)
loessCurv <- loess(survRatio~ageGroup)
lines(predict(loessCurv), col="red", lwd=2)
abline(titanicLM)
```

The option `col=` defines the color of a line/plot and `lwd=` the line width.

For comparison reasons we also added here the linear model result via `abline()`

---

## Hands on: Run some own linear regression on the stress data

---

## Solutions:

---

## Export figures

Exporting figures in R is extremely easy. All one needs to specify is the graphic type (e.g. `png`, `jpeg`, `pdf` or `eps`).

When a plot command is executed, R opens a graphical device (like a canvas) and uses this device then to plot the requested things onto.

The default device is the screen. If one wants to store a figure on the HDD, all one has to do is to define a non-standard graphical device and
its dimensions, then plot into that device and eventually close the device so that it will be finalized. 

The following commands can be used to export figures.

---

## Export figures

Here a table with commands:

---

## Export data

And then still how to save dataframes/workspaces.



